# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать как стандартные алгоритмические конструкции 
с декларативным стилем программирования, так и тензорные вычисления для задач машинного обучения.

Основной особенностью языка является простой, логичный и непротиворечивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в том числе операторов языка).

Текущая версия 0.2 от 11.08.2022 ([Новое в текущей версии и история выпусков](https://newlang.net/versions.html))

## Основные свойства и особенности языка:
- возможность работы как в режиме интерпретатора, так и компилятора
- динамическая и статическая типизация с возможностью указания типов в явном виде
- статическая типизация является условно-строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных. Например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот)
- автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная типизация»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) 
- на уровне синтаксиса поддерживается несколько типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- необязательные и именованные параметры функций
- возможны вставки кода на языке реализации (С/С++)
- простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)
- имеется REPL [read-eval-print loop — «цикл: чтение — вычисление — вывод»](https://ru.wikipedia.org/wiki/REPL)

----------
*Данные возможности запланированы к реализации при создании компилятора

---
[Синтаксис языка](https://newlang.net/syntax.html)

[Подробное описание системы типов](https://newlang.net/types.html)

[Операторы и управляющие конструкции](https://newlang.net/ops.html)

**Пример скрипта Hello world! на NewLang**
```
    #!../output/nlc --eval

    # Определение функции hello
    hello(str) := { 
      printf := :Pointer('printf(format:FmtChar, ...):Int32');  # Импорт стандартной C функции
      printf('%s', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
      $str;
    };
    hello('Привет, мир!'); # Вызвать функцию
```
Вывод: 
``` 
    Привет, мир!
    Привет, мир!
```
(первая строка выводится с помощью printf, а вторая - возвращаемое значение функции hello)


## Зачем нужен *NewLang*?

У всех современных языков программирования происходит постоянное развитие (усложнение) синтаксиса по мере выхода новых версий. Это является своего рода платой за появление новых возможностей и воспринимается пользователями как естественное явление.

Но одновременно является и серьезной проблемой, так как с выходом версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.

У *NewLang* сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части - это упрощает его изучение и использование.

*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах. *Расширенный синтаксис* — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.

Еще одно неудобство современных языков в том, что большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов. Это же касается и вычислений с неограниченной точностью, которые так же не поддерживаются синтаксисом языка и реализуются с помощью вызовов библиотечных функций.

У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)), а арифметические типы данных являются скалярами (тензорами нулевой размерности). На уровне синтаксиса поддерживаются рациональные числа неограниченной точности, которые реализованы с использованием длинной арифметики из библиотеки Х.
У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)), а арифметические типы данных являются скалярами (тензорами нулевой размерности). На уровне синтаксиса поддерживаются рациональные числа неограниченной точности, которые реализованы с использованием длинной арифметики из библиотеки [OpenSSL]().


**Пример скрипта для вычисления факториала 1000 на NewLang**
```
    #!../output/nlc --eval

    @fact := 1\1;  # Рациональное число без органичений точности
    @mult := 1000..1..-1?; # Получить итератор для множителей от 1000 до 2
    [mult?!] <<-->> {      # Цикл, пока не закончатся данные итератора
      fact *= mult!;  # Получить текущий множитель и перейти на следующий элемент итератора
    };
    fact # Вывести итоговый результат

```
Вывод:
``` 
    402387260077093773543702433923003985719374864210714632543799910429938512398629
    020592044208486969404800479988610197196058631666872994808558901323829669944590
    997424504087073759918823627727188732519779505950995276120874975462497043601418
    278094646496291056393887437886487337119181045825783647849977012476632889835955
    735432513185323958463075557409114262417474349347553428646576611667797396668820
    291207379143853719588249808126867838374559731746136085379534524221586593201928
    090878297308431392844403281231558611036976801357304216168747609675871348312025
    478589320767169132448426236131412508780208000261683151027341827977704784635868
    170164365024153691398281264810213092761244896359928705114964975419909342221566
    832572080821333186116811553615836546984046708975602900950537616475847728421889
    679646244945160765353408198901385442487984959953319101723355556602139450399736
    280750137837615307127761926849034352625200015888535147331611702103968175921510
    907788019393178114194545257223865541461062892187960223838971476088506276862967
    146674697562911234082439208160153780889893964518263243671616762179168909779911
    903754031274622289988005195444414282012187361745992642956581746628302955570299
    024324153181617210465832036786906117260158783520751516284225540265170483304226
    143974286933061690897968482590125458327168226458066526769958652682272807075781
    391858178889652208164348344825993266043367660176999612831860788386150279465955
    131156552036093988180612138558600301435694527224206344631797460594682573103790
    084024432438465657245014402821885252470935190620929023136493273497565513958720
    559654228749774011413346962715422845862377387538230483865688976461927383814900
    140767310446640259899490222221765904339901886018566526485061799702356193897017
    860040811889729918311021171229845901641921068884387121855646124960798722908519
    296819372388642614839657382291123125024186649353143970137428531926649875337218
    940694281434118520158014123344828015051399694290153483077644569099073152433278
    288269864602789864321139083506217095002597389863554277196742822248757586765752
    344220207573630569498825087968928162753848863396909959826280956121450994871701
    244516461260379029309120889086942028510640182154399457156805941872748998094254
    742173582401063677404595741785160829230135358081840096996372524230560855903700
    624271243416909004153690105933983835777939410970027753472000000000000000000000
    000000000000000000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000000000000000000000000\1
```



### Загрузка бинарных сборок
[Бинарная сборка и тесты (пока только под Ubuntu)](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_bin.tar.xz)  
Для запуска бинарных сборок потребуются разделяемые библиотеки libLLVM-13 и libtorch ([архив с библиотеками](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_so.tar.xz)).

## Сборка из исходников
### Подготовка репозитория
- Скачать исходники [https://github.com/rsashka/newlang](https://github.com/rsashka/newlang)
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.12.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-shared-with-deps-1.12.1+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-1.12.1%2Bcpu.zip)
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh`
- В каталоге *src* запустить файл `compile_syntax.sh` для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит *flex* и *bison* (flex 2.6.4 и bison (GNU Bison) 3.7.4)

### Сборка
- Юнит-тесты (nlc_test): в каталоге *src* выполнить команду `make CONF=UnitTest_LLVM`  
- Интерпретатор (nlc): в каталоге *src* выполнить команду `make CONF=Debug_LLVM`  

---
 Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile «из коробки», тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. 
 
 Уже начал постепеный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скиптов сборки с помощью сmake, но этот процесс пока не завершен. 
