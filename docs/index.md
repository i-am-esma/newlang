# Проект *NewLang*
*NewLang* - это язык программирования высокого уровня в котором можно сочетать как стандартные алгоритмические конструкции 
с декларативным стилем программирования, так и тензорные вычисления для задач машинного обучения.

Основной особенностью языка является простой, логичный и непротиворечивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в том числе операторов языка).

Текущая версия 0.2 от 11.08.2022 ([Новое в текущей версии и история выпусков](https://newlang.net/versions.html))

## Основные свойства и особенности языка:
- возможность работы как в режиме интерпретатора, так и компилятора
- динамическая и статическая типизация с возможностью указания типов в явном виде
- статическая типизация является условно-строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных. Например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот)
- автоматическое управление памятью
- ООП в виде явного наследования классов и [«утиная типизация»](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) 
- на уровне синтаксиса поддерживается несколько типов функций (обычные и [чистые функции без побочных эффектов](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8))
- необязательные и именованные параметры функций
- возможны вставки кода на языке реализации (С/С++)
- простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++.)
- имеется REPL [read-eval-print loop — «цикл: чтение — вычисление — вывод»](https://ru.wikipedia.org/wiki/REPL)

----------
*Данные возможности запланированы к реализации при создании компилятора

---
[Синтаксис языка](https://newlang.net/syntax.html)

[Подробное описание системы типов](https://newlang.net/types.html)

[Операторы и управляющие конструкции](https://newlang.net/ops.html)

**Пример скрипта Hello world! на NewLang**
```
    #!../output/nlc --eval

    # Определение функции hello
    hello(str) := { 
      printf := :Pointer('printf(format:FmtChar, ...):Int32');  # Импорт стандартной C функции
      printf('%s', $str);  # Вызов C функции с проверкой типов аргументов по строке формата
      $str;
    };
    hello('Привет, мир!'); # Вызвать функцию
```
Вывод: 
``` 
    Привет, мир!
    Привет, мир!
```
(первая строка выводится с помощью printf, а вторая - возвращаемое значение функции hello)


## Зачем нужен *NewLang*?

У всех современных языков программирования происходит постоянное развитие (усложнение) синтаксиса по мере выхода новых версий. Это является своего рода платой за появление новых возможностей и воспринимается пользователями как естественное явление.

Но одновременно является и серьезной проблемой, так как с выходом версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.

У *NewLang* сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части - это упрощает его изучение и использование.

*Основной синтаксис* — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах. *Расширенный синтаксис* — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.

Еще одно неудобство современных языков в том, что большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов. Это же касается и вычислений с неограниченной точностью, которые так же не поддерживаются синтаксисом языка и реализуются с помощью вызовов библиотечных функций.

У *NewLang* тензорные вычисления доступны «из коробки» (используется библиотека [libtorch](https://pytorch.org/)), а арифметические типы данных являются скалярами (тензорами нулевой размерности). На уровне синтаксиса поддерживаются рациональные числа неограниченной точности, которые реализованы с использованием больших чисел из библиотеки [OpenSSL](https://github.com/openssl/openssl/blob/master/crypto/bn/README.pod).


**Пример скрипта для вычисления факториала 100 на NewLang**
```
    #!../output/nlc --eval

    @fact := 1\1;  # Рациональное число без органичений точности
    @mult := 100..1..-1?; # Получить итератор для множителей от 100 до 2
    [mult ?!] <-> {      # Цикл, пока не закончатся данные итератора
      fact *= mult !;  # Получить текущий множитель и перейти на следующий элемент итератора
    };
    fact # Вывести итоговый результат

```
Вывод:
``` 
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```



### Загрузка бинарных сборок
[Бинарная сборка и тесты (пока только под Ubuntu)](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_bin.tar.xz)  
Для запуска бинарных сборок потребуются разделяемые библиотеки libLLVM-13 и libtorch ([архив с библиотеками](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_so.tar.xz)).

## Сборка из исходников
### Подготовка репозитория
- Скачать исходники [https://github.com/rsashka/newlang](https://github.com/rsashka/newlang)
- Скачать и развернуть архив [libtorch](https://pytorch.org/) в каталоге *contrib* (PyTorch Build: Stable (1.12.*) -> Your OS: Linux -> Package: LibTorch -> Language: C++ / Java -> Compute Platform: CPU -> Download here (cxx11 ABI):
[libtorch-shared-with-deps-1.12.1+cpu.zip](https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-1.12.1%2Bcpu.zip)
- Активировать и скачать исходники субмодулей (`git submodule init && git submodule update`)
- В каталоге *contrib* запустить файл `build.sh`
- В каталоге *src* запустить файл `compile_syntax.sh` для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит *flex* и *bison* (flex 2.6.4 и bison (GNU Bison) 3.7.4)

### Сборка
- Юнит-тесты (nlc_test): в каталоге *src* выполнить команду `make CONF=UnitTest_LLVM`  
- Интерпретатор (nlc): в каталоге *src* выполнить команду `make CONF=Debug_LLVM`  

---
 Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile «из коробки», тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. 
 
 Уже начал постепеный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скиптов сборки с помощью сmake, но этот процесс пока не завершен. 
