# Синтаксис NewLang (0.3)

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии соответствуют стилю С/С++ и должны располагаться между символами /* и */. Многосточные комментарии могут быть вложенными.
- Последовательность команд, которая должна выполняться как единое целое заключается в фигурные скобки «{}» и возвращает результат последней операции *(что очень похоже на оператор **запятая** в языках С/С++)*.

### Правила именования объектов и типов данных

В качестве идентификаторов объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой. Подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.

Перед именем может быть указан специальный префикс (модификатор), который состоит из одного символа и имеет определнное значение:
#### Префиксы (модификаторы)
- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
- **:** — двоеточие вначале идентификатора используется для указания имени [типа](https://newlang.net/types.html)
- **::** — двойные двоеточия являются разделителями для указания пространства имен
- **@** — Префикс **@** обозначает программный модуль
- **\\** — обратная коса черта является модификатором у имени макроса

Если перед именем объекта модификатор не указан, сперва он проверяется на имя макроса, потом на локальную переменную и в последнюю очередь на имя объекта модуля.

### Локальные и глобальные переменные
В *NewLang* по умолчанию переменная создается как глобальная статическая, которая сохраняет свое состояние между вызовами.

Чтобы создать локальную перемененную, перед её именем необходимо указать знак доллара **$**, тогда такая переменная будет уничтожаться при выходе из текущей области видимости. 
Если условно классифицировать эти два варианта переменных, то можно считать, что переменная по умолчанию создается в куче, а локальная с префиксом **$** на стеке.

Семантика локальных переменных, а так же аргументов у функций очень похожа на аргументы в bash скриптах, где **$1** или **$arg** — порядковый номер или имя аргумента.

### Пространства имен
*NewLang* одновременно поддерживает и пространства имен, как в языке C++, так и модульную структуру кода как в языках Java и Python.
Синтаксис для указания пространства имен очень похож на С++. Имена разделяются двойным двоеточием, а для определение пространства имен, его нужно указать перед открывающейся фигурной скобкой.
```
ns {
    name {
        var := 0; # Имя переменной будет ns::name::var
        ::var := 1; # Переменная из глобального пространства имен
    }
}
```

### Программные модули
В *NewLang* реализована концепция программных модулей - которая повторяет идею иерархического расположения файлов в структуре каталогов файловой системы, так же, как это сделано в языках Python и Java. Имя программного модуля начинается на префикс **@**, а структура каталогов указывается через точку. 

Причем в именовании объектов концепции программных модулей и пространства имен объединены. Например, полное имя переменой можно записать с указанием программного модуля `@root.dir.module::ns::name::var`, где **root** и **dir** это каталоги в файловой системе, а **module** — имя файла, т.е. *root/dir/module.nlp*

Области видимости объектов определяются аналогично прияным в языке Python с помощью подчерков перед именем переменной.

Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.
Но так же как и в языке Python области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени, доступ к защищенным объектам можно получить указав их полное имя. Системные поля и объекты начинаются и заканчиваются на два подчерка.

### Макросы

Макросы в *NewLang*, это один или несколько терминов, которые заменяется на другой термин или на целую синтаксическую конструкцию (последовательность лексем). Макросы являются одновременно и раширением базового синтаксиса языка при реализации собственных диалектов DSL и синтаксическим сахаром. Главная особенность макросов в том, что они позволяют изменять выражения еще до их вычисления во время выполнения. А так как раскрытие макросов происходит на этапе синтаксического анализа, это позвоялет подменять ими любые другие термины и даже модифицировать сам синтаксис *NewLang*. 

Пока текущая реализация макросов предназначена для проверки общей концепции их использования и в будущем может немного измениться. Поэтому, сейчас раскрытие и проверки макросов сделаны в объеме, который минимально достаточен для их начального использования. я препроцессора в C/C++.

#### Определение макросов
Макрос создается по тем же самым правилам, что и обычная переменная. Идентификатором макроса может быть одиночное имя (термин с префиксом макроса) или  последовательность из нескольких лексем, которая записывается между двумя обратными слешами. 
В качестве тела (значения) у макроса может быть термин или корректное выражение языка, например: `\обычный_макрос := 123;`, `\\два термина\\ := {func(); func2(123);};` или последовательность лексем, которая записывается  между двумя обратными слешами `\макрос_из_лексем := \\ call1(); call2(); call3() \\;`.
Тело текстового макроса записывается между тремя обратными слешами: `\текстовый_макрос := \\\ исходный текст программы для лексера \\\;`.

> Первоначальноа у меня было желание ограничить время жизни макросов так же как у локальных переменных - только текущей областью видимости, чтобы при её завершении макрос удаляется автоматически. Но макросы обработываются раньше, чем происходит анализ входных лексем парсером (т.е. раньше, чем формируются сами области видимости). А перенести обработку макросов на более поздний этап, например, после создания синтаксичсекого дереава, так же не получается, так как пропадет возможность модифицировать AST во время парсинга исходного кода. Поэтому пришлось выбирать между локальными областями видимости у макросов и возможностьию модификации абстрактного синтаксического дерева, и в результате я выбрал последнее. Поэтому, макросы могут произвольным образом менять синтаксис языка, но всегда имеют глобальную область видимости где бы они не были объявлены.

Для удаления макросов требуется использовать специальный синтаксис: `\\\\ name \\\\;` или `\\\\ \\два термина\\ \\\\;`, т.е. указать идентификатор макроса между четырмя обратными слешами. Необходимость использования отдельной синтасической конструкции для удаления макросов вызвана тем, что они обработываются и раскрываются еще до этапа анализа в парсере. Из-за этого операторы [создания и присвоения значения](https://newlang.net/ops.html) в полном объеме работают только с макросами, идентификаторами которых выступают последовательность лексем, тогда как создание макроса с идентификатором из одиночного термина может быть только оператор создания или присвоения, т.е. `\macro := new_expression;`, а использование операторов `::=` и `=` не допускается.

Один из терминов в идентификаторе макроса может иметь аргументы, которые указываются в круглых скобках. Аргументы в теле макроса записываются как имя локальной переменой, но перед её именем (или порядковым номером аргумента) нужно добавить обратный слеш, т.е. `\$name` или `\$1`.
```
    # Обычные макросы (тело макроса корректное выражение)
    \macro      := replace();
    \macro2(arg)   := { call(\$arg); call()};
    \\name1 name2\\  := replace();

    # Тело макросов из последовательности лексем
    \if(...)    := \\ [ \$* ]--> \\; # Выражение может быть не полным
    \elif(...)  := \\ ,[ \$* ]--> \\;
    \else       := \\ ,[ _ ]--> \\;
 
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    \macro_str  := \\\ строка - тело макроса \\\; # Строка для лексера
    
    # Оператор удаления макроса (любого другого объекта?????)
    \\\\macro_str\\\\;

    # Классическая запись условного оператора
    # с использованием определнных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```




В настоящий момент макросы реализоаны следующим образом.  


Идентификатор мароса, левое выражение от оператора присвоения, может быть одиночным термином или состоять из лексем (одного или нескольких терминов, которые заисны между двойными слешами), а тело марокса макроса так же может быть одиночным термином, состоять из лексем или быть обычной текстовой строкой, которая будет анализироваться парсером только после раскрытия тела макроса (как в препроцессоре С/С++).
```
   # Тело макроса полное (корректное) выражение
    \macro      := replace(); 
    \macro2(arg)   := { call(\$arg); call()};
    \\lexem1 lexem2\\  := replace();

    # Тело макросов из последовательности лексем
    # и может быть не полным выражением
    \if(...)    := \\ [ \$* ]--> \\; 
    \elif(...)  := \\ ,[ \$* ]--> \\;
    \else       := \\ ,[ _ ]--> \\;
 
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    \macro_str  := \\\ строка - тело макроса \\\; # Строка для лексера
```

- Обычный макрос  - заменяет один или сразу несколько терминов на тело макроса. Тело обычного макроса может быть корректным выражением языка или последовательности лексем, которые будут анализироваться парсером только после раскрытия макроса. Таким образом можно модифицировать базовый синтаксис языка за счет применения сразу нескольких макросов при записи одного оператора (см. условный оператор или оператор выбора).
- Текстовый макрос - так же заменяет один или несколько терминов, но его тело представляет собой обычный текстовый фрагмент исходного кода, который во время раскрытия макроса передается на вход лексера. Фактически, текстовые макросы это полный аналог макросов дл




Макросы используются и для превращеня базового синтаксиса *NewLang*, в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    \if(...)     ::= \\ [ \$* ]--> \\;
    \while(...)  ::= \\ [\$*] <-> \\;
    \return $arg ::=  \\ -- \$arg -- \\;
    \true ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```

С полным списком макросов можно ознакомится [тут](https://newlang.net/syntax_dsl.html) или посмотреть исходный [код программного модуля](https://github.com/rsashka/newlang/blob/master/examples/dsl.nlp).


### Специальные идентификаторы
- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы текущей функции или модуля
- **@\*** — Все аргументы запущенной программы

- **$$** — родительский объект (в том числе и при переопределении функций).
- **@@** — Системный контекст
- **@$** — Текущий модуль

Проверить, является ли текущий модуль основным, можно протестировав его нулевой аргумент. У основного модуля программы, нулевой аргумент всегда будет содержать имя исполняемого файла, а остальные аргументы соответствовать параметрам командной строки (если они есть). Если файл загружен как модуль,
то нулевой аргумент у модуля будет пустым.
```
# Аналог проверки в Python
# if __name__ == "__main__": 

[@$.$0] --> { # или \ifmain при использовании макросов из модуля @dsl
    ...
};
```

### Зарезервированные имена компилятора

При работе парсера *NewLang* автоматически генерируются несколько зарезервированных имен, которые можно использовать как обычные константы.
Большинство из них соответствуют макросам препроцессора у С/С++:

- \_\_FILE\_\_ - расширяется до полного пути к текущему файлу
- \_\_LINE\_\_ - содержит номер текущей строки
- \_\_TIMESTAMP\_\_ - дату и время последней модификации текущего файла
- \_\_MD5\_\_ - md5 хеш текущего файла

- \_\_DATE\_\_ - дата и время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении
- \_\_NLC_VER\_\_ - версия NewLang

- \_\_SOURCE_GIT\_\_ - идентификатор исходных файлов NewLang git репозитория, использованных при сборке
- \_\_DATE_BUILD\_\_ - дата сборки исходников NewLang
- \_\_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной строкой

### Системные свойства

Несмотря на то, что не все объекты *NewLang* являются классами с точки зрения [реализованной концепции ООП](https://newlang.net/type_oop.html), тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:

#### У всех переменных (объектов) есть системные свойства
- \_\_name\_\_ - краткое имя переменной (объекта)
- \_\_full_name\_\_ - полное имя переменной, включая имя модуля и пространство имен
- \_\_type\_\_ - текущий тип переменной. Может изменится при некоторых операциях
- \_\_type_fixed\_\_ - тип переменной (объекта) который не может измениться (ограничитель)
- \_\_module\_\_ - имя модуля в котором определена переменная (объект)
- \_\_class\_\_ - имя класса переменной или пусто, если объект не является классом
- \_\_base\_\_ - словарь со списком базовых классов или пусто, если объект не является классом
- \_\_size\_\_ - количество элементов у объекта, если применимо или :None 

- \_\_doc\_\_ - документация по текущему объекту (если есть, иначе пустая строка)
- \_\_str\_\_ - строковое представление объекта для дампа
- \_\_source\_\_ - исходный текст модуля или функции

#### Системные свойства у модулей
- \_\_file\_\_ - полный путь к файлу модуля (соответствует макросу \_\_FILE\_\_)
- \_\_timestamp\_\_ - дата и время последней модификации файла модуля (соответствует макросу \_\_TIMESTAMP\_\_)
- \_\_md5\_\_ - хеш исходных данных модуля (соответствует макросу \_\_MD5\_\_)


