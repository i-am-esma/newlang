# Макросы

Макросы в **NewLang**, это один или несколько последовательных терминов, которые заменяются на другой термин 
или на целую синтаксическую конструкцию (последовательность лексем). 

Макросы обработываются во время работы **лексера**, т.е. перед передачей последовательности лексем в парсер, 
что позволяет с их помощью изменять любые последовательности термины и даже сам синтаксис языка, например, 
для реализации собственных диалектов DSL.

### Определение макросов

Для определения макросов используется такой-же синтаксис, как и для других объектов языка.
Определение макроса состоит из трех частей **<имя макроса> <оператор создания/присвоения> <тело макроса>** и завершающая точка с запятой **;**,
т.е. применяются операторы **::=**/**::-**, **=** или **:=**/**:-** для создания нового объекта, 
присвоение нового значения уже существующему объекту или для создания/присвоения нового значения объекту 
не зависимо от его наличия или отсутствия.


### Тело макроса

Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные обратные слеши, 
т.е. `\\лексема1 лексема1\\`) или обычная текстовая строка (обрамленная в тройные обратные слеши, т.е. `\\\ текстовая строка \\\`).

### Имя макроса

Именем макроса может быть одна или нескольких лексем (терминов), которые заключаются между двумя обратными слешами.
В имени макроса кроме лексем (терминов) могут присутствовать один или несколько шаблонов.

*Шаблон* — это термин, который при сопоставлении последовательности лексем с идентификатором макроса 
может заменяться любым другим одиночным термином (реализуется сопоставление имени макроса по образцу (шаблону).

Для создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), 
т. е. `\\одна_лексема\\, \\целых три термина\\ или \\термин $шаблон1 $шаблон2\\`.

Имена макросов считаются одинаковыми, если количество элементов в их именах совпадает, термины и шаблоны располагаются 
на тех же самых местах, а сами термины в идентификаторах одинаковые.

### Удаление макросов

Для удаления макросов используется специальный синтаксис: `\\\\ name \\\\;` или `\\\\ два термина \\\\;`, 
т.е. необходимо указать идентификатор макроса между четырмя обратными слешами.

```bash
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    \\macro_str\\  := \\\ строка - тело макроса \\\; # Строка для лексера

    # Оператор удаления макроса
    \\\\ macro_str \\\\;
```

### Аргументы макросов

Во всех языках программирования макросы можно определять как с аргументами, так и без аргументов. 
И как правило, макропроцессор считает макросы с аргументами и без оных идентичными, что не позволяет определять 
два макроса с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.  

Но такое ограничение усложняет заменую одного термина на другой, если термины могут применяться в двух разных варинатах использования,
т.е. и с аргументами и без аргументов одновремнно. (Например, в С/С++ это вызов функции и получение адреса функции).

Из-за этого в язык **NewLang** добавлен еще один вариант макроса (алиас), который игнорирует наличие аргументов 
и может использоваться как со скобкам (аргументами), так и без них, а имена макросов сравниваются без учета аргументов (скобок).


```bash
    \\alias\\ :- term; # Алиас - определение без аргументов
    
    # Использование макроса - алиаса
    alias; # ОК -> term;
    alias(args); # ОК -> term(args);

    # Но 
    \\var\\ := term; 
    \\call()\\ := term(); 

    # Использование
    var; # ОК -> term;
    call(); # ОК -> term();

    var(); # Ошибка (var определен без аргументов) 
    call; # Ошибка (call определен с аргументами) 
```

Для создания макросов без аргументов (алиасов) используются операторы как для создания чистых функций (**::-** или **:-**). 

При сопоставлении идентификаторов таких макросов учитываются только последовательность лексем и шаблонов, 
что позволяет из примернять как к функциям, так и к обычным переменным для замены одних терминов на другие, 
а любые виды скобок (и данные внутри них) при сопоставлении игнорируются.  

#### Раскрытие аргументов в теле макроса

У обычных макросов термины и шаблоны в имени макроса могут иметь аргументы, которые указываются в разных видах скобках. 
Обычные макросы при сопоставлении с последовательностью лексем требуют наличие аргументов в определении имени маркоса.  

Чтобы в теле макроса указать место для вставки аргумента, его нужно записать как имя локальной переменой, 
но перед ним добавить обратный слеш, т.е. **\\$name**.

Произвольное количество аргументов у макроса отмечается троеточием "...", а место для вставки этих аргументов отмечается 
специальной лексемой. Для вставки всех аргументов из конкретного идентификатора используется лексема 
с указанием соотвутствующего имени, например, **\\$name(\*)**, **\\$name<\*>** или **\\$name[\*]** в зависимости от типов скобок, 
где **name**, это имя термина или шаблона, который имеет аргументы (т.е. после которого стоят скобки соответствующего вида).  

Для вставки количества реально переданных аргументов используется лексемы **\\$name(#)**, **\\$name<#>** 
или **\\$name[#]** с указанием соответствующего идентификатора.


#### Дополнительные возможности макросов

По аналогии с препроцессором С/С++ для соединения двух лексем в одну в теле макроса используется оператор **\\##**, 
а для преобразование лексемы текстову строку оператор **\\#**, например, `\\macro($arg)\\ := \\ func_ \## \$arg(\#arg) \\;`, 
тогда вызов `macro(name);` будет преобразован в `func_name ("name");`

*Парсер при обработке макросов может анализировать информацию о типах данных, если она указана.* 
*Но на текущий момент типы данных в макросах никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.*

### Примеры макросов

```bash
    # Обычные макросы (тело макроса корректное выражение)
    \\macro\\        := replace();
    \\macro2(arg)\\  := { call(\$arg); call()};
    \\name1 name2\\  := replace();

    # Тело макросов из последовательности лексем
    \\if(...)\\    := \\ [ \$if(*) ]--> \\; # Выражение может быть не полным
    \\elif(...)\\  := \\ ,[ \$elif(*) ]--> \\;
    \\else\\       := \\ ,[_]--> \\;
 
    # Классическая запись условного оператора
    # с использованием определнных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```




# Систематизация реализации макросов

Разбор макросов происходит в лексере. Определением макроса всегда является целая строка, 
которая заканчивается точкой с запятой, а идентификатором макроса всегда выступает последовательность лексем:
```bash
    \\ id \\ := macro;
    \\ id \\ := \\ \\;
    \\ id \\ := \\\ \\\;
```
Хранилищем текущих максросов является объект класса MacroBuffer. 
Последовательность лексем идентификатора (id) макроса должна сохраняется в отдельном поле термина и однозначно его идентифицирует.
Первый термин в идентификаторе хранится как ключ hashmap, а дальше происходит поиск полным перебором.
Этапы работы с макросами

- Входные термины из лексера получаются вызовом GetNextToken, внутри которой и происходит раскрытие макросов.
Внутренний буфер заполняется до окончания строки (выражения), т.е. до символа ';' или <END>, после чего производится 
поиск макросов в объекте MacroBuffer для текущей последовательности лексем в буфере.

- Если макрос найден, то соответствющая ему последоваетльность заменяется на тело макроса и происходит переход 
на повторный анализ входного буфера.

- Если макрос не найден, то данные передаются в парсер для дальнейшего синтаксическго анализа.

- Для этого во входном потоке лексем (parser.y) во время оператората создания/присвоения вызывается функция проверки на макрос.
MacroBuffer::CheckMacroAndConvertDel($$), и после этого выходному значению присваивается результат выполнения driver.MacroEval($$),
и в дальнейшем этот макрос никак не обработывается.

- Создание макросов, проверка на дубликаты и логические ошибки в определении происходит путем обращения к методам объекта MacroBuffer.


# Ограничения текущей реализации !!!!

На текущий момент макросы делаются для следующих сценариев использования:

- DSL для keyword based syntax (if, else, return, match, while  и т.д.) - (1 термин с произвольными аргументами и без) - требуется сейчас !!!


- Определения (func, class) - (несколько терминов с аргументами и без аргументов) - Реализация ООП и импорт С++ классов
- Модификации при определениях (override) - (несколько терминов и шаблоны с аргументами и без аргументов) - Реализация ООП и импорт С++ классов


# МАКРОСЫ БЕЗ АРГУМЕНТОВ ИЛИ ВСЕ АРГУМЕНТЫ СРАЗУ !!!!!
# анализа аргументов или их типов не производится !!!







    /*
     * Макросы хрянтся как фрагменты AST в виде объектов типа Term,
     * так как создаются после обработки парсером по правилам стандратной грамматики.
     * 
     * Но анализ входных данных на предмет раскрытия макросов проиходит из потока (последовательности) лексем,
     * т.е. **ДО** обработки парсером, так как при раскрытии макросов может меняться грамматика выражений.
     * 
     * Функция \ref CompareMacro сравнивает входной буфер (последовательность лексем)
     * на предмет возможного соответствия одному конкретному макросу.
     * Сравниваются только ключевые словам без учета аргументов в скобках, 
     * но само наличие аргументов проверяется ??????????????????
     * 
     * Проблема:
     * К функции можно обратится с целью её вызова (указав после имени скобки), 
     * так и по имени без скобок (например для получения ссылки на объект).
     * Так и к переменной можно обратиться только по имени, 
     * так и указав скобки после имени как к функции (при копировании объекта).
     * 
     * Сделать один макрос под оба сценария (со скобками и без скобок) не получится, так как непонятно, 
     * что делать с аргументами при раскрытии тела макроса, когда они не указаны.
     * 
     * Но может быть следует переименовывать только одно имя без учета скобок,
     * например, оставив такую возможность только для одиночных макросов.
     * 
     * \name -> name или name (...), hash: name
     * но \name(...) -> name(...), а name - ошибка !!!!  hash: name
     * 
     * Или все же следует различать макросы со скобками и без скобок как два разных объекта???
     * \name := name2;  и \name(...) := name2(...); будут разными объектами
     * 
     * Или добавить макросы-алиасы без аргументов только для переименования отдельных терминов?
     * \alias :- name2; но как их отличать от обычных макросов в операции удаления?
     * Или вообще не нужно отличать и оставить только один варинат (либо макрос, либо алиас)
     * Тода вопрос со скобками закрывается сам собой, алиасы всегда без скобок,
     * макросы со скбками или без скобок, но должно быть полное соответствие.
     * 
     * \\ name name2 \\ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * \\ name name2(...) \\ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * \\ name name2[...](...) \\ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * \\ name $tmpl[...](...) name3\\ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Но!
     * \\ name name2 \\ ::-  -> name name2 - ок, но name name2(...) - ок
     * \\ name $tmpl name3\\ ::- -> name $tmpl[...](...) name3 - ок, name $tmpl(...) name3[...] - ок
     * 
     * 
     * 
     * Для последовательности лексем требуется полное соответствие с учетом скобок ???
     * и может ли быть несколько скобок одного типа (несколько крыглях, или несколько квардратных????
     * <Может быть несколько скобок одного типа, например, при указании типа у аргументов или типа возвращаемого значения.>
     * 
     * \\ name name2 \\ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * \\ name name2(...) \\ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * \\ name name2[...](...) \\ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * \\ name $tmpl[...](...) name3\\ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Проблема скобок возникает из-за сценария замены одного термина на другой, 
     * который есть в препроцессоре С/С++, но отсутствует при реализации с использованием шаблонов.
     * 
     *      
     */






Макросы используются и для превращеня исходного кода *NewLang* в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    \\if(...)\\    ::= \\ [ \$* ]--> \\;
    \\while(...)\\ ::= \\ [\$*] <-> \\;
    \\return $arg\\::=  \\ -- \$arg -- \\;
    \\true\\ ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```

С полным списком макросов можно ознакомится [тут](https://newlang.net/syntax_dsl.html) или посмотреть исходный [код программного модуля](https://github.com/rsashka/newlang/blob/master/examples/dsl.nlp).


### Специальные идентификаторы
- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы текущей функции или модуля
- **@\*** — Все аргументы запущенной программы

- **$$** — родительский объект (в том числе и при переопределении функций).
- **@@** — Системный контекст
- **@$** — Текущий модуль

Проверить, является ли текущий модуль основным, можно протестировав его нулевой аргумент. У основного модуля программы, нулевой аргумент всегда будет содержать имя исполняемого файла, а остальные аргументы соответствовать параметрам командной строки (если они есть). Если файл загружен как модуль,
то нулевой аргумент у модуля будет пустым.
```
# Аналог проверки в Python
# if __name__ == "__main__": 

[@$.$0] --> { # или \ifmain при использовании макросов из модуля @dsl
    ...
};
```

### Зарезервированные имена компилятора

При работе парсера *NewLang* автоматически генерируются несколько зарезервированных имен, которые можно использовать как обычные константы.
Большинство из них соответствуют макросам препроцессора у С/С++:

- \_\_FILE\_\_ - расширяется до полного пути к текущему файлу
- \_\_LINE\_\_ - содержит номер текущей строки
- \_\_TIMESTAMP\_\_ - дату и время последней модификации текущего файла
- \_\_MD5\_\_ - md5 хеш текущего файла

- \_\_DATE\_\_ - дата и время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении
- \_\_NLC_VER\_\_ - версия NewLang

- \_\_SOURCE_GIT\_\_ - идентификатор исходных файлов NewLang git репозитория, использованных при сборке
- \_\_DATE_BUILD\_\_ - дата сборки исходников NewLang
- \_\_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной строкой

### Системные свойства

Несмотря на то, что не все объекты *NewLang* являются классами с точки зрения [реализованной концепции ООП](https://newlang.net/type_oop.html), тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:

#### У всех переменных (объектов) есть системные свойства
- \_\_name\_\_ - краткое имя переменной (объекта)
- \_\_full_name\_\_ - полное имя переменной, включая имя модуля и пространство имен
- \_\_type\_\_ - текущий тип переменной. Может изменится при некоторых операциях
- \_\_type_fixed\_\_ - тип переменной (объекта) который не может измениться (ограничитель)
- \_\_module\_\_ - имя модуля в котором определена переменная (объект)
- \_\_class\_\_ - имя класса переменной или пусто, если объект не является классом
- \_\_base\_\_ - словарь со списком базовых классов или пусто, если объект не является классом
- \_\_size\_\_ - количество элементов у объекта, если применимо или :None 

- \_\_doc\_\_ - документация по текущему объекту (если есть, иначе пустая строка)
- \_\_str\_\_ - строковое представление объекта для дампа
- \_\_source\_\_ - исходный текст модуля или функции

#### Системные свойства у модулей
- \_\_file\_\_ - полный путь к файлу модуля (соответствует макросу \_\_FILE\_\_)
- \_\_timestamp\_\_ - дата и время последней модификации файла модуля (соответствует макросу \_\_TIMESTAMP\_\_)
- \_\_md5\_\_ - хеш исходных данных модуля (соответствует макросу \_\_MD5\_\_)



