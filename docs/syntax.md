# Синтаксис NewLang (0.3)

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии соответствуют стилю С/С++ и должны располагаться между символами /* и */. Многосточные комментарии могут быть вложенными.
- Последовательность команд, которая должна выполняться как единое целое заключается в фигурные скобки «{}», а так как возвращается результат последней операции, то это очень похоже на оператор *запятая* в языках С/С++.

### Правила именования объектов и типов данных

В качестве идентификаторов объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.

#### Префиксы и разделители
- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
- **:** — двоеточие вначале идентификатора используется для указания имени [типа](https://newlang.net/types.html).
- **::** — двойные двоеточия являются разделителями для указания пространства имен.
- **@** — Префикс **@** обозначает программный модуль.
- **\\** — обратная коса черта является модификатором для указания имени макроса.

### Локальные и глобальные переменные
В *NewLang* по умолчанию переменная создается как глобальная статическая, которая сохраняет свое состояние между вызовами.

Чтобы создать локальную перемененную, перед её именем необходимо указать знак доллара **$**, тогда такая переменная будет уничтожаться при выходе из текущей области видимости. 
Если условно классифицировать эти два варианта переменных, то можно считать, что переменная по умолчанию создается в куче, а локальная с префиксом **$** на стеке.

Семантика локальных переменных, а так же аргументов у функций очень похожа на аргументы в bash скриптах, где **$1** или **$arg** — порядковый номер или имя аргумента.

### Пространства имен
*NewLang* одновременно поддерживает и пространства имен, как в языке C++, так и модульную структуру кода как в языках Java и Python.
Синтаксис для указания пространства имен очень похож на С++. Имена разделяются двойным двоеточием, а для определение пространства имен, его нужно указать перед открывающейся фигурной скобкой.
```
ns {
    name {
        var := 0; # Имя переменной будет ns::name::var
        ::var := 1; # Переменная из глобального пространства имен
    }
}
```

### Программные модули
В *NewLang* реализована концепция программных модулей - которая повторяет идею иерархического расположения файлов в структуре каталогов файловой системы, так же, как это сделано в языках Python и Java. Имя программного модуля начинается на префикс **@**, а структура каталогов указывается через точку. 

Причем в именовании объектов концепции программных модулей и пространства имен объединены. Например, полное имя переменой можно записать с указанием программного модуля `@root.dir.module::ns::name::var`, где **root** и **dir** это каталоги в файловой системе, а **module** — имя файла, т.е. *root/dir/module.nlp*

Области видимости объектов определяются аналогично прияным в языке Python с помощью подчерков перед именем переменной.
Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.
Но так же как и в языке Python области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени, доступ к защищенным объектам можно получить указав их полное имя. Системные поля и объекты начинаются и заканчиваются на два подчерка.

### Макросы

Макросы или синонимы в *NewLang*, это идентификатор без префикса, который заменяется на тело реального идентиффикатора или целой синтаксической конструкции. Макросы по сути являются одновременно и раширением синтаксиса для реализации различных диалектов DSL и синтаксическим сахаром, так как только у используемых макросов отсутствует префикс, обязательный для всех остальных терминов языка.

Макросы бывают двух видов и обладаюят немного отличающими свойствами. Обычные макросы и алиасы (синонимы). И те и другие доступные в как во время компиляяции, так и в рантайме и отличаются тем, что один алиас всегда преобразуется в **один** термин языка, который не является макросом, тогда как обычный макрос может преобразовываться сразу в несколько различных синтаксических конструкций. Следствием подобных отличия явлется то, что алиас может обрабатываться очень быстро так как для этого требуется только выполнить поиск нужного термина в таблице символов. Тогда как для раскрытия *полноценного* макроса необходима обработка исходного тескта препроцессором для развертывания других макросов, парсинг получившегося текста для создания нового AST и его повторный анализ.

Раскрытие макросов производится на отдельном этапе обработки входного файла и выполняется не с помощью синтаксического разбора текста программы, а прямой  заменой с помощью регулярных выражений.
\\macro  MACRO\\\\  
\\macro\\\  
\\_\\\\  

{
    \alias ALIAS\\    <- алиас есть идентификатор !!!! можно удалять  \alias\\ \alias NEW_ALIAS\\  или \_\\ или все? 
    \::alias2 ALIAS\\  <- нужен ли namespace для алиасов?????????????????
    \\macro name name \\ MACRO\\\  <- макрос на шаблонах нет идентификатора !!!! Как удалять?
    Если будет область видимости у макросов, то namespace им будет не нужен !!!!
} <<<<<<<<<<<<<<<<<<<<<<<  ????????????????????????????

alias - не определено
alias2 (или ::alias2) - определено ??????????????????????
macro - определено ??


\macro\\ 
\macro\\ 

\_\\  
\@_\\  
\_\\  

загружать инклуды (файлы модули)
Перед парсингом макросов делается один большой файл, котором после 

__LINE__ = 1111;


макроса перед обработкой исходного текста программы парсером. Так как тело макроса может содержать любой текст или последовательность символов, то для их определения существует специальный синтаксис. 

С помощью макросов можно расширять NewLang новыми языковыми формами и даже определить собственный предметно-ориентированный диалект языка для конкретной задачи, так как раскрытие макросов происходит **до** обработки текста парсером. Поэтому в теле парсера могут содержаться в том числе и различные части языковых конструкций.

Макросы используются и для более привычного вида текста программы, превращая базовый синтаксис *NewLang* в синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.

Макрос в исходном тексте программы всегда начинается на обратный слеш (бекслеш) **\\**, т.е. *\name* или *\macro(arg1, arg2)*. 
Формат определения макроса - два обратных слеша, имя определяемого макроса, аргументы (если они есть), тело макроса, три обратных слеша. 

В тело макроса можно вставить переданные в макрос аргументы. К аргументу макроса можно обратиться по его имени, порядковому номеру или ко всем аргументам сразу. 
Чтобы вставить аргумент в тело макроса, перед его именем или порядковым номером нужно записать обратный слеш и знак доллара, т.е. `\$name` или `\$1`. 
А чтобы вставить в тело макроса сразу все аргументы разом, нужно указать `\$*`.







Макросы в *NewLang*, это специальный идентификатор, который заменяется на тело макроса перед обработкой исходного текста программы парсером. Так как тело макроса может содержать любой текст или последовательность символов, то для их определения существует специальный синтаксис. 

С помощью макросов можно расширять NewLang новыми языковыми формами и даже определить собственный предметно-ориентированный диалект языка для конкретной задачи, так как раскрытие макросов происходит **до** обработки текста парсером. Поэтому в теле парсера могут содержаться в том числе и различные части языковых конструкций.

Макросы используются и для более привычного вида текста программы, превращая базовый синтаксис *NewLang* в синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.

Макрос в исходном тексте программы всегда начинается на обратный слеш (бекслеш) **\\**, т.е. *\name* или *\macro(arg1, arg2)*. 
Формат определения макроса - два обратных слеша, имя определяемого макроса, аргументы (если они есть), тело макроса, три обратных слеша. 

В тело макроса можно вставить переданные в макрос аргументы. К аргументу макроса можно обратиться по его имени, порядковому номеру или ко всем аргументам сразу. 
Чтобы вставить аргумент в тело макроса, перед его именем или порядковым номером нужно записать обратный слеш и знак доллара, т.е. `\$name` или `\$1`. 
А чтобы вставить в тело макроса сразу все аргументы разом, нужно указать `\$*`.

[Например:](https://newlang.net/syntax_dsl.html).
```
\\if(...) [\$*]--> \\\
\\elif((...) ,[\$*]--> \\\
\\else ,[_]--> \\\

\\while(cond) [\$cond] <-> \\\
\\dowhile(cond) <-> [\$cond] \\\

\\return --\\\
\\return(...) -- \$* --\\\

\\true 1\\\
\\false 0\\\
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
\while( \true ) {
    \if(count>5) {
        \return(42);
    };
count+=1;
};
```

С полным списком макросов можно ознакомится [тут](https://newlang.net/syntax_dsl.html) или посмотреть исходный [код программного модуля](https://github.com/rsashka/newlang/blob/master/examples/dsl.nlp).

### Специальные идентификаторы
- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы текущей функции или модуля
- **@\*** — Все аргументы запущенной программы

- **$$** — родительский объект (в том числе и при переопределении функций).
- **@@** — Системный контекст
- **@$** — Текущий модуль

Проверить, является ли текущий модуль основным, можно протестировав его нулевой аргумент. У основного модуля программы, нулевой аргумент всегда будет содержать имя исполняемого файла, а остальные аргументы соответствовать параметрам командной строки (если они есть). Если файл загружен как модуль,
то нулевой аргумент у модуля будет пустым.
```
# Аналог проверки в Python
# if __name__ == "__main__": 

[@$.$0] --> { # или \ifmain при использовании макросов из модуля @dsl
    ...
};
```

### Зарезервированные имена компилятора

При работе парсера *NewLang* автоматически генерируются несколько зарезервированных имен, которые можно использовать как обычные константы.
Большинство из них соответствуют макросам препроцессора у С/С++:

- \_\_FILE\_\_ - расширяется до полного пути к текущему файлу
- \_\_LINE\_\_ - содержит номер текущей строки
- \_\_TIMESTAMP\_\_ - дату и время последней модификации текущего файла
- \_\_MD5\_\_ - md5 хеш текущего файла

- \_\_DATE\_\_ - дата и время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении
- \_\_NLC_VER\_\_ - версия NewLang

- \_\_SOURCE_GIT\_\_ - идентификатор исходных файлов NewLang git репозитория, использованных при сборке
- \_\_DATE_BUILD\_\_ - дата сборки исходников NewLang
- \_\_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной строкой

### Системные свойства

Несмотря на то, что не все объекты *NewLang* являются классами с точки зрения [реализованной концепции ООП](https://newlang.net/type_oop.html), тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:

#### У всех переменных (объектов) есть системные свойства
- \_\_name\_\_ - краткое имя переменной (объекта)
- \_\_full_name\_\_ - полное имя переменной, включая имя модуля и пространство имен
- \_\_type\_\_ - текущий тип переменной. Может изменится при некоторых операциях
- \_\_type_fixed\_\_ - тип переменной (объекта) который не может измениться (ограничитель)
- \_\_module\_\_ - имя модуля в котором определена переменная (объект)
- \_\_class\_\_ - имя класса переменной или пусто, если объект не является классом
- \_\_base\_\_ - словарь со списком базовых классов или пусто, если объект не является классом
- \_\_size\_\_ - количество элементов у объекта, если применимо или :None 

- \_\_doc\_\_ - документация по текущему объекту (если есть, иначе пустая строка)
- \_\_str\_\_ - строковое представление объекта для дампа
- \_\_source\_\_ - исходный текст модуля или функции

#### Системные свойства у модулей
- \_\_file\_\_ - полный путь к файлу модуля (соответствует макросу \_\_FILE\_\_)
- \_\_timestamp\_\_ - дата и время последней модификации файла модуля (соответствует макросу \_\_TIMESTAMP\_\_)
- \_\_md5\_\_ - хеш исходных данных модуля (соответствует макросу \_\_MD5\_\_)


