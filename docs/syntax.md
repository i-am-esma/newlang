# Синтаксис NewLang

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии в соответствуют стилю С/С++ и должны располагаться между символами /* и */. Многосточные комментарии могут быть вложенными.
- Последовательность команд, которая должна выполняться как единое целое заключается в фигурные скобки «{}», а так как возвращается результат последней операции, то это похоже на оператор запятая в языках С/С++.
- Программные вставки на языке реализации заключается в фигурные скобки со знаком процента {% /* тут может быть любой код на C/C++*/ %}.


## Правила именования объектов и типов данных

В качестве идентификаторов объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.

В *NewLang* по умолчанию переменная создается как глобальная статическая, которая сохраняет свое состояние между вызовами.
Чтобы создать локальную пемененную, время жизни которой будет ограничено текущей областью видимости, 
а при её завершении локальная переменная уничтожается, перед её именем необходимо указать знак доллара **$**. 
Таким образом семантика локальных переменных, а так же аргументов функций очень похожа на работу с аргументами в bash скриптах, 
где $1 или $arg — порядковый номер или имя аргумента.

- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
- **@** — обозначает статическую переменную модуля, которая сохраняет свое состояние даже после выхода из текущей области видимости.
- **:** — двоеточие вначале идентификатора используется для указания имени типа.
- **\\** — обратная коса черта является модификатором для указания имени макроса.
- **%** — знак процента вначале идентификатора используется для указания нативного имени и применяется при импорте С/С++ функций.
- **::** — двойные двоеточия являются разделителями для указания пространства имен.

*NewLang* одноврмененно поддерживает и пространства имен, как в языке C++, так и моудльную структуру кода как в языках Java и Python.
Для указания глобального namespace и для разделения вложенных пространств имен между собой используется два символа двоеточия.
Перед именем модуля используется префикс **@**, а разделителем в иерархии модулей является точка. 
Таким образом запись иерархии модулей соотвествует общепринятому в Java и Python синтасису, 
а полный формат имени объекта с указанием пространства имен будет таким: @dir.file::ns::name::var, 
что соответствует переменной **var** в пространстве имен **ns::name** в файле **"dir\file"**.

Области видимости объектов определяются аналогично прияным в языке Python с помощью подчерков перед именем переменной.
Один подчерк соответствует защишенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.
Но так же как и в языке Python сейчас области видимости больше соотвествуют "джентельменской" договоренности, 
но при явном указании имени, доступ к защищенным объектам можно получить зная указав их полное имя.



### Зарезервированные имена
- **@@** — Основной модуль запущенной программы или None, если выполение происходит в командном режиме
- **@$** — Текущий модуль или None, если выполение происходит в командном режиме
- **$$** — родительский объект (в том числе и при переопределении функицй).

- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы

## Использование модификаторов является обязательным в следующих случаях:

- При указании имени макроса или типа данных, так как макросы и типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными.
- При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++.

В остальных случаях, для обращения к переменным указывать их модификаторы необязательно. И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем. Причем, локальная переменная будет перекрывать глобальную.

Так же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции, тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать в код runtime вызов функции поиска объекта в глобальной таблице символов по его имени.

## Макросы

Макросы в NewLang, это специальный идентификатор, который заменяется на тело макроса перед обработкой исходного текста программы парсером. Так как тело макроса может содержать любой текст или последовательность символов, то для их определения существует специальный синтаксис. 

С помощью макросов можно расширять NewLang новыми языковыми формами и даже определить собственный предметно-ориентированный диалект языкы для конкретной задачи.  
Или использовать их просто для удобства и более привычного вида алгоритмических конструкций.

Макрос в исходном тексте программы всегда начинается на обратный слеш (бекслеш) **\\**, т.е. *\name* или *\macro(arg1, arg2)*.  
Формат определения макроса - два обратных слеша, имя определяемого макроса, аргументы (если они есть), тело макроса, три обратных слеша.  

В тело макроса можно вставить переданные в макрос аргументы. К аргументу макроса можно обратиться по его имени, порядковому номеру или ко всем аргументам сразу.  
Чтобы вставить аргумент в тело макроса, перед его именем или порядковым номером нужно записать обратный слеш и знак доллара, т.е. **\\$name** или **\\$1**.  
А чтобы вставить в тело макроса сразу все аргументы разом, нужно указать **\\$***.

Например:
```
    \\if(cond)       [\$cond]--> \\\
    \\elif(cond)     ,[\$cond]--> \\\
    \\else           ,[_]--> \\\

    \\while(cond)    [\$cond] <-> \\\
    \\dowhile(cond)  <-> [\$cond] \\\

    \\return         --\\\
    \\return(...)    -- \$* --\\\

    \\true      1\\\
    \\false     0\\\
```

Тогда цикл до 5:
```
    count:=1;
    [ 1 ] <-> {
        [count>5] --> {
            -- 42 --;
        };
        count+=1;
    };
```

будет выгладеть более привычно
```
    count:=5;
    \while( \true ) {
        \if(count>5) {
            \return(42);
        };
        count+=1;
    };
```
