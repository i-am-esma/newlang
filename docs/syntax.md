# Синтаксис NewLang

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии в соответствуют стилю С/С++ и должны располагаться между символами /* и */. Многосточные комментарии могут быть вложенными.
- Последовательность команд, которая должна выполняться как единое целое, заключается в фигурные скобки «{}».
- Программные вставки на языке реализации заключается в фигурные скобки со знаком процента %{ /* тут может быть любой код на C/C++*/ %} (такой синтаксис соотвествсует принятому в лексерах).


## Идентификаторы объектов и модификаторы

В качестве идентификаторов можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.

В *NewLang* существует возможность указания назначение, область видимости и времени жизни объекта с помощью модификатора — специального символа перед именем переменной. Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее, модификатор не имеет отношения к типу объекта и не является частью имени идентификатора. К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.

- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
- **@** — обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости.
- **:** — двоеточие вначале идентификатора используется в качестве модификатора для указания имени типа данных.
- **\\** — обратная коса черта вначале идентификатора используется в качестве модификатора для указания имени макроса.

Семантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где $1 или $arg — порядковый номер или имя аргумента (происходит обращение к локальным переменным в текущей области видимости).


## Использование модификаторов является обязательным в следующих случаях:

- При указании имени макроса или типа данных, так как макросы и типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными.
- При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++.

В остальных случаях, для обращения к переменным указывать их модификаторы необязательно. И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем. Причем, локальная переменная будет перекрывать глобальную.

Так же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции, тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать в код runtime вызов функции поиска объекта в глобальной таблице символов по его имени.

## Макросы

Макросы в NewLang, это специальный идентификатор, который заменяется на тело макроса перед обработкой исходного текста программы парсером. Так как тело макроса может содержать любой текст или последовательность символов, то для их определения существует специальный синтаксис. 

С помощью макросов можно расширять NewLang новыми языковыми формами и даже определить собственный предметно-ориентированный диалект языкы для конкретной задачи.  
Или использовать их просто для удобства и более привычного вида алгоритмических конструкций.

Макрос в исходном тексте программы всегда начинается на обратный слеш (бекслеш) **\\**, т.е. *\name* или *\macro(arg1, arg2)*.  
Формат определения макроса - два обратных слеша, имя определяемого макроса, аргументы (если они есть), тело макроса, три обратных слеша.  

В тело макроса можно вставить переданные в макрос аргументы. К аргументу макроса можно обратиться по его имени, порядковому номеру или ко всем аргументам сразу.  
Чтобы вставить аргумент в тело макроса, перед его именем или порядковым номером нужно записать обратный слеш и знак доллара, т.е. **\\$name** или **\\$1**.  
А чтобы вставить в тело макроса сразу все аргументы разом, нужно указать **\\$***.

Например:
```
    \\if(cond)       [\$cond]--> \\\
    \\elif(cond)     ,[\$cond]--> \\\
    \\else           ,[_]--> \\\

    \\while(cond)    [\$cond] <<-->> \\\
    \\dowhile(cond)  <<-->> [\$cond] \\\

    \\return         --\\\
    \\return(...)    -- \$* --\\\

    \\true      1\\\
    \\false     0\\\
```

Тогда цикл до 5:
```
    count:=1;
    [ 1 ] <<-->> {
        [count>5] --> {
            -- 42 --;
        };
        count+=1;
    };
```

будет выгладеть более привычно
```
    count:=5;
    \while( \true ) {
        \if(count>5) {
            \return(42);
        };
        count+=1;
    };
```