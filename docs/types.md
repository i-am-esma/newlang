## Система типов NewLang
Так *NewLang* является языком с динамической типизацией, то явное указание типа не влияет на размер памяти, занимаемой переменной и в основном определяет логические ограничения на возможность присвоения переменной значения другого типа.

Информация о типах используется при проверке их совместимости, когда существующему объекту присваивается значение другого типа. Такая операция возможна только когда типы совместимы между собой и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.

Согласно [правилам синтаксиса](https://newlang.net/syntax.html) *NewLang*, имя типа всегда начинается с двоеточия **:**.

- [Числа](https://newlang.net/type_nor.html)

- [Строки](https://newlang.net/type_str.html) 

- [Функции](https://newlang.net/type_func.html)

- [Итераторы](https://newlang.net/type_iter.html)

- [Словари и классы](https://newlang.net/type_oop.html)

- [Специальные типы](https://newlang.net/type_other.html)

- [Нативные типы данных](https://newlang.net/type_native.html)

### Преобразование типов

Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется его явное преобразование.

Так как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Int64() и т.д.

Примеры:
```
# Создать тензор из строки широких символов с автоматическим выводом типа
#(тип Int32 будет на системах с Linux, а под Windows тип тензора будет Int16)
> tstr := :Tensor("Тест"); 
[1058, 1077, 1089, 1090,]:Int32

# Тоже самое, но тензор заданной размерности
> t2 := :Tensor[2,2]("Тест");
[
[1058, 1077,], [1089, 1090,],
]:Int32

# Создать символьную строку из тензора
> :StrWide(tstr) 
Тест

# Изменить тип данных тензора без изменения размерности
> :Float64(t2) 
[
[1058, 1077,], [1089, 1090,],
]:Float64

# Изменить размерность тензора и его тип 
# (в данном случае с частичной потерей данных)
> t3 := :Int8[4]( t2 ) 
[34, 53, 65, 66,]:Int8

# Создать тензор из словаря
>:Tensor( (1,2,3,) ); 
[1, 2, 3,]:Int8

# Преобразовать байтовую строку в тензор
>:Tensor( 'first second' ) 
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8

# Получаем тензор из словаря с такими же данными
>:Tensor( (first='first', space=32, second='second',) ) 
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8

# Тензор заданного формата с нулями,
# где многоточие повторяет последнее значение до требуемого размера
>:Float64[10,2]( 0, ...) 
[
[0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,],
]:Float64

# Тензор со случайными данными, где между многоточиями указана функция,
# которую следует вызывать каждый раз при получении нового элемента тензора
#
# Тут пришлось придумывать новую синтаксическую конструкцию 
# для вызова функции для каждого нового элемента, т.к. многоточие 
# перед идентификатором, это оператор раскрытия словаря, 
# а многоточие после идентификатора, это повторение последнего 
# значения до конца заданной размерности.
>:Int32[3,2]( ... rand() ...) 
[
[1804289383, 846930886,], [1681692777, 1714636915,], [1957747793, 424238335,],
]:Int32

# Создание тензора из диапазона
>:Int32[5,2]( 0..10 ); 
[
[0, 1,], [2, 3,], [4, 5,], [6, 7,], [8, 9,],
]:Int32

# Или даже так
>:Tensor( 0..0.99..0.1 ); 
[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,]:Float64
```


