# История версий языка NewLang

## [Релиз 0.4 (в разработке)](https://github.com/rsashka/newlang/releases/tag/v0.4.0)
### Новые возможности и изменения в синтаксисе NewLang

Внеочередная версия c новой реализацией парсера, который может модифицировать входные данные непосредственно во время синтаксического анализа. Это потребовалось для раскрытия макросов и поддержки новых возможностей синтаксиса:
- Теперь макросы записываются без обратного слеша и могут быть двух типов: обычные и алиасы которые отличаются возможностью изменения AST
- Алиасы - упрощенная форма макроса, которая предназначена только для замены одного термина на другой и не требует изменения синтаксического дерева (AST)
- Обычные макросы - могут как угодно изменять итоговое синтаксическое дерево во время парсинга исходного кода
- Оба варианта макросов поддерживают области видимости блоков и автоматически удаляются после завершения блока в котором макрос был определен
- Каждый варинта макроса может быть только в одном экземпляре (при попытке переопределения выводится сообщение о дублировании, которое можно скрывать???).
- Если требуется переопределить уже существующий макрос, то перед этим его следует удалить.

Этапы работы парсера/компилятора:
- Преобразование исходника в AST с раскрытыми макросами и алиасами
- Создание списка имен используемых типов, функций и переменных с проверкой их корректности
- Выполнение AST (интерпретирование) 
- В будущем - преобразование списка в имен в объекты LLVM в памяти (JIT)

Выполнение файла программы:
- Парсинг исходного текста и раскритие макросов производится во время одного прохода.
- При анализе лексером текущего файла токены перед передачей в парсер добавляются в хвост временного буфера **БЕЗ АНАЛИЗА СИНТАКСИЧЕСКОГО ДЕРЕВА**.
- После добавления нового токена в буфер, он проверяется на возможность раскрытия **макросов** (не *алиасов*!!) для текущего уровня вложенности.
- Создание новых макросов привязывается к текущему уровню вложенности и при его уменьшении, удаляются макросы которые вышли из области видимости.
- Текущий токент проверяется на определение нового макроса (и при его наличии создается с привязкой к текущему уровню вложенности макросов)
- Если встречается оператор импорта модуля, то проверяется загружен ли модуль. Если модуль **НЕ** загружен, тогда начинает выполняться новый модуль с текущим контекстом макросов.
- В текущий контекст импортируются функции нового модуля.
- В парсер (и на выполнение) передаются токены из головы буфера, размер которого больше, чем кол-во токенов самого длинного макроса.
- При завершении файла в парсер передаются все оставшието токены из буфера.


Реализация:
1. Лексер с буфером - полное повторение входных данных при любом размере буфера
2. Ограничение размера буфера в зависимости от количества и размера текущих макросов
3. Формирование уровня вложенности макросов
4. Создание и удаление макросов с привязкой к уровню вложенности
5. Поиск токенов загрузки модулей и переключение на их выполнение
6. Оставшиеся тесты с несколькими уровнями вложений импорта модулей, включая рекурсивный



- Ссылки
- Константы
- Документирующие комментарии




- Конструкторы и дестуркторы у классов

- Космический корабль для арифметического сравнения
\name \name2\
\name(arg, arg2) name2(\$arg1+1, \$arg2)\
\name\name2\
\name($arg, $arg2)\name2($arg1, $arg2)\
\name($arg, ...)\name2($arg1, ...)\
\$1<=>$2\\
$1.op_spaseship($2);
$1.op_spaseship($2);
\\

\($1...)<=>($2...)\\$1.op_spaseship($2)\\\ ??????????????????

\{
\name \name2\\
\name(arg, arg2) name2(\$arg1+1, \$arg2)\\
\name\name2\\

\name\\\
\\$1<=>$2\\\\\
\}

\\class $name {\\:$name() ::= {\\\
\\class $name : parent $parent {\\:$name() ::= $parent(){\\\
\\class $name : parent ... {\\:$name() ::= ...() {\\\


\\$type $name (...) {\\$name(...) : $type ::= {\\\
\\$type $name (...) override {\\$name(...) : $type = {\\\

\\ $1 <=> $2 \\  $1.op_spaseship(\$2)\\\
- Постепенное превращение в рантайм надстройку над С++?????????????????????????????
- Объекты с типами Struct, Union, Enum для работы с нативными функциями
- Новый синтаксис для имен нативных функций
- Импорт нативных С++ функций
- Импорт С++ классов
- Примеры кода с машинным обучением


### Разное
- 

---


## [Релиз 0.3 (07.11.2022) - текущая версия](https://github.com/rsashka/newlang/releases/tag/v0.3.0)
### Новые возможности и изменения в синтаксисе NewLang
- Простые чистые функции удалены.
- Зафиксирован синтаксис операторов проверки [условия](https://newlang.net/ops.html#условный-оператор) и [циклов](https://newlang.net/ops.html#операторы-циклов). 
- Оператор цикла **while** теперь поддерживает конструкцию [**else**](https://newlang.net/ops.html#операторы-циклов).
- В синтаксис NewLang добавлены [пространства имен](https://newlang.net/syntax.html#пространства-имен).
- Реализована часть концепции ООП и добавлена поддержка [определения классов](https://newlang.net/type_oop.html).
- Переработана идеология [возвратов из функции и обработки исключений](https://newlang.net/newlang_doc.html#операторы-прерывания-выполнения-оператор-возврата).

### Разное
- Выполнен переход на clang 15
- Реализован вызов функций с помощью libffi
- Сделана полноценная поддержка Windows

---

## [Релиз 0.2 (11.08.2022)](https://github.com/rsashka/newlang/releases/tag/v0.2.0)
### Новые возможности и изменения в синтаксисе NewLang
- Добавлены макросы (появилась возможность использовать более привычный синтаксис на основе ключевых слов)
- Реализованы итераторы
- Добавлен новый тип данных - рациональные числа не ограниченной точности
- Многострочные комментарии стали вложенными
- Имена встроенных типов переименованы с указанием размерности

### Другие важные изменения
- Вместо использования gcc перешел на clang, а libffi замененил на JIT компиляцию вызова для нативных функций
- В релиз добавлены бинарные сборки для Linux
- Начало портирования кода на Windows

## [Релиз 0.1 (24.06.2022) - первая публичная версия](https://github.com/rsashka/newlang/releases/tag/v0.1.0)
- Представление общей концепции языка
- Сборка тестов и примеров под Linux из исходников

